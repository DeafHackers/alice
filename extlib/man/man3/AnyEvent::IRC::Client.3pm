.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::IRC::Client 3"
.TH AnyEvent::IRC::Client 3 "2011-02-28" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::IRC::Client \- A highlevel IRC connection
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use AnyEvent;
\&   use AnyEvent::IRC::Client;
\&
\&   my $c = AnyEvent\->condvar;
\&
\&   my $timer;
\&   my $con = new AnyEvent::IRC::Client;
\&
\&   $con\->reg_cb (connect => sub {
\&      my ($con, $err) = @_;
\&      if (defined $err) {
\&         warn "connect error: $err\en";
\&         return;
\&      }
\&   });
\&   $con\->reg_cb (registered => sub { print "I\*(Aqm in!\en"; });
\&   $con\->reg_cb (disconnect => sub { print "I\*(Aqm out!\en"; $c\->broadcast });
\&   $con\->reg_cb (
\&      sent => sub {
\&         my ($con) = @_;
\&
\&         if ($_[2] eq \*(AqPRIVMSG\*(Aq) {
\&            print "Sent message!\en";
\&
\&            $timer = AnyEvent\->timer (
\&               after => 1,
\&               cb => sub {
\&                  undef $timer;
\&                  $con\->disconnect (\*(Aqdone\*(Aq)
\&               }
\&            );
\&         }
\&      }
\&   );
\&
\&   $con\->send_srv (
\&      PRIVMSG => \*(Aqelmex\*(Aq,
\&      "Hello there I\*(Aqm the cool AnyEvent::IRC test script!"
\&   );
\&
\&   $con\->connect ("localhost", 6667, { nick => \*(Aqtestbot\*(Aq });
\&   $c\->wait;
\&   $con\->disconnect;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
AnyEvent::IRC::Client is a (nearly) highlevel client connection,
that manages all the stuff that noone wants to implement again and again
when handling with \s-1IRC\s0. For example it PONGs the server or keeps track
of the users on a channel.
.PP
This module also implements the \s-1ISUPPORT\s0 (command 005) extension of the \s-1IRC\s0 protocol
(see http://www.irc.org/tech_docs/005.html) and will enable the \s-1NAMESX\s0 and \s-1UHNAMES\s0
extensions when supported by the server.
.PP
Also \s-1CTCP\s0 support is implemented, all \s-1CTCP\s0 messages will be decoded and events
for them will be generated. You can configure auto-replies to certain \s-1CTCP\s0 commands
with the \f(CW\*(C`ctcp_auto_reply\*(C'\fR method, or you can generate the replies yourself.
.SS "A \s-1NOTE\s0 \s-1TO\s0 \s-1CASE\s0 \s-1MANAGEMENT\s0"
.IX Subsection "A NOTE TO CASE MANAGEMENT"
The case insensitivity of channel names and nicknames can lead to headaches
when dealing with \s-1IRC\s0 in an automated client which tracks channels and nicknames.
.PP
I tried to preserve the case in all channel and nicknames
AnyEvent::IRC::Client passes to his user. But in the internal
structures I'm using lower case for the channel names.
.PP
The returned hash from \f(CW\*(C`channel_list\*(C'\fR for example has the lower case of the
joined channels as keys.
.PP
But I tried to preserve the case in all events that are emitted.
Please keep this in mind when handling the events.
.PP
For example a user might joins #TeSt and parts #test later.
.SH "EVENTS"
.IX Header "EVENTS"
The following events are emitted by AnyEvent::IRC::Client.
Use \f(CW\*(C`reg_cb\*(C'\fR as described in Object::Event to register to such an event.
.IP "registered" 4
.IX Item "registered"
Emitted when the connection got successfully registered and the end of the \s-1MOTD\s0
(\s-1IRC\s0 command 376 or 422 (No \s-1MOTD\s0 file found)) was seen, so you can start sending
commands and all \s-1ISUPPORT/PROTOCTL\s0 handshaking has been done.
.ie n .IP "channel_add => $msg, $channel, @nicks" 4
.el .IP "channel_add => \f(CW$msg\fR, \f(CW$channel\fR, \f(CW@nicks\fR" 4
.IX Item "channel_add => $msg, $channel, @nicks"
Emitted when \f(CW@nicks\fR are added to the channel \f(CW$channel\fR,
this happens for example when someone JOINs a channel or when you
get a \s-1RPL_NAMREPLY\s0 (see \s-1RFC1459\s0).
.Sp
\&\f(CW$msg\fR is the \s-1IRC\s0 message hash that as returned by \f(CW\*(C`parse_irc_msg\*(C'\fR.
.ie n .IP "channel_remove => $msg, $channel, @nicks" 4
.el .IP "channel_remove => \f(CW$msg\fR, \f(CW$channel\fR, \f(CW@nicks\fR" 4
.IX Item "channel_remove => $msg, $channel, @nicks"
Emitted when \f(CW@nicks\fR are removed from the channel \f(CW$channel\fR,
happens for example when they \s-1PART\s0, \s-1QUIT\s0 or get KICKed.
.Sp
\&\f(CW$msg\fR is the \s-1IRC\s0 message hash that as returned by \f(CW\*(C`parse_irc_msg\*(C'\fR
or undef if the reason for the removal was a disconnect on our end.
.ie n .IP "channel_change => $msg, $channel, $old_nick, $new_nick, $is_myself" 4
.el .IP "channel_change => \f(CW$msg\fR, \f(CW$channel\fR, \f(CW$old_nick\fR, \f(CW$new_nick\fR, \f(CW$is_myself\fR" 4
.IX Item "channel_change => $msg, $channel, $old_nick, $new_nick, $is_myself"
Emitted when a nickname on a channel changes. This is emitted when a \s-1NICK\s0
change occurs from \f(CW$old_nick\fR to \f(CW$new_nick\fR give the application a chance
to quickly analyze what channels were affected.  \f(CW$is_myself\fR is true when
yourself was the one who changed the nick.
.ie n .IP "channel_nickmode_update => $channel, $dest" 4
.el .IP "channel_nickmode_update => \f(CW$channel\fR, \f(CW$dest\fR" 4
.IX Item "channel_nickmode_update => $channel, $dest"
This event is emitted when the (user) mode (eg. op status) of an occupant of
a channel changes. \f(CW$dest\fR is the nickname on the \f(CW$channel\fR who's mode was
updated.
.ie n .IP "channel_topic => $channel, $topic, $who" 4
.el .IP "channel_topic => \f(CW$channel\fR, \f(CW$topic\fR, \f(CW$who\fR" 4
.IX Item "channel_topic => $channel, $topic, $who"
This is emitted when the topic for a channel is discovered. \f(CW$channel\fR
is the channel for which \f(CW$topic\fR is the current topic now.
Which is set by \f(CW$who\fR. \f(CW$who\fR might be undefined when it's not known
who set the channel topic.
.ie n .IP "ident_change => $nick, $ident" 4
.el .IP "ident_change => \f(CW$nick\fR, \f(CW$ident\fR" 4
.IX Item "ident_change => $nick, $ident"
Whenever the user and host of \f(CW$nick\fR has been determined or a change
happened this event is emitted.
.ie n .IP "join => $nick, $channel, $is_myself" 4
.el .IP "join => \f(CW$nick\fR, \f(CW$channel\fR, \f(CW$is_myself\fR" 4
.IX Item "join => $nick, $channel, $is_myself"
Emitted when \f(CW$nick\fR enters the channel \f(CW$channel\fR by JOINing.
\&\f(CW$is_myself\fR is true if yourself are the one who JOINs.
.ie n .IP "part => $nick, $channel, $is_myself, $msg" 4
.el .IP "part => \f(CW$nick\fR, \f(CW$channel\fR, \f(CW$is_myself\fR, \f(CW$msg\fR" 4
.IX Item "part => $nick, $channel, $is_myself, $msg"
Emitted when \f(CW$nick\fR PARTs the channel \f(CW$channel\fR.
\&\f(CW$is_myself\fR is true if yourself are the one who PARTs.
\&\f(CW$msg\fR is the \s-1PART\s0 message.
.ie n .IP "kick => $kicked_nick, $channel, $is_myself, $msg, $kicker_nick" 4
.el .IP "kick => \f(CW$kicked_nick\fR, \f(CW$channel\fR, \f(CW$is_myself\fR, \f(CW$msg\fR, \f(CW$kicker_nick\fR" 4
.IX Item "kick => $kicked_nick, $channel, $is_myself, $msg, $kicker_nick"
Emitted when \f(CW$kicked_nick\fR is KICKed from the channel \f(CW$channel\fR by
\&\f(CW$kicker_nick\fR.  \f(CW$is_myself\fR is true if yourself are the one who got KICKed.
\&\f(CW$msg\fR is the \s-1KICK\s0 message.
.ie n .IP "nick_change => $old_nick, $new_nick, $is_myself" 4
.el .IP "nick_change => \f(CW$old_nick\fR, \f(CW$new_nick\fR, \f(CW$is_myself\fR" 4
.IX Item "nick_change => $old_nick, $new_nick, $is_myself"
Emitted when \f(CW$old_nick\fR is renamed to \f(CW$new_nick\fR.
\&\f(CW$is_myself\fR is true when yourself was the one who changed the nick.
.ie n .IP "away_status_change => $bool" 4
.el .IP "away_status_change => \f(CW$bool\fR" 4
.IX Item "away_status_change => $bool"
Emitted whenever a presence/away status change for you was detected.
\&\f(CW$bool\fR is true if you are now away, or false/undef if you are not
away anymore.
.Sp
You can change your away status by emitting the \f(CW\*(C`AWAY\*(C'\fR \s-1IRC\s0 command:
.Sp
.Vb 1
\&   $cl\->send_srv (AWAY => "I\*(Aqm not here right now");
.Ve
.Sp
Or reset it:
.Sp
.Vb 1
\&   $cl\->send_srv (\*(AqAWAY\*(Aq);
.Ve
.ie n .IP "ctcp => $src, $target, $tag, $msg, $type" 4
.el .IP "ctcp => \f(CW$src\fR, \f(CW$target\fR, \f(CW$tag\fR, \f(CW$msg\fR, \f(CW$type\fR" 4
.IX Item "ctcp => $src, $target, $tag, $msg, $type"
Emitted when a \s-1CTCP\s0 message was found in either a \s-1NOTICE\s0 or \s-1PRIVMSG\s0
message. \f(CW$tag\fR is the \s-1CTCP\s0 message tag. (eg. \*(L"\s-1PING\s0\*(R", \*(L"\s-1VERSION\s0\*(R", ...).
\&\f(CW$msg\fR is the \s-1CTCP\s0 message and \f(CW$type\fR is either \*(L"\s-1NOTICE\s0\*(R" or \*(L"\s-1PRIVMSG\s0\*(R".
.Sp
\&\f(CW$src\fR is the source nick the message came from.
\&\f(CW$target\fR is the target nickname (yours) or the channel the ctcp was sent
on.
.ie n .IP """ctcp_$tag"", => $src, $target, $msg, $type" 4
.el .IP "``ctcp_$tag'', => \f(CW$src\fR, \f(CW$target\fR, \f(CW$msg\fR, \f(CW$type\fR" 4
.IX Item "ctcp_$tag, => $src, $target, $msg, $type"
Emitted when a \s-1CTCP\s0 message was found in either a \s-1NOTICE\s0 or \s-1PRIVMSG\s0
message. \f(CW$tag\fR is the \s-1CTCP\s0 message tag (in lower case). (eg. \*(L"ping\*(R", \*(L"version\*(R", ...).
\&\f(CW$msg\fR is the \s-1CTCP\s0 message and \f(CW$type\fR is either \*(L"\s-1NOTICE\s0\*(R" or \*(L"\s-1PRIVMSG\s0\*(R".
.Sp
\&\f(CW$src\fR is the source nick the message came from.
\&\f(CW$target\fR is the target nickname (yours) or the channel the ctcp was sent
on.
.ie n .IP "dcc_ready => $id, $dest, $type, $local_ip, $local_port" 4
.el .IP "dcc_ready => \f(CW$id\fR, \f(CW$dest\fR, \f(CW$type\fR, \f(CW$local_ip\fR, \f(CW$local_port\fR" 4
.IX Item "dcc_ready => $id, $dest, $type, $local_ip, $local_port"
Whenever a locally initiated \s-1DCC\s0 request is made this event is emitted
after the listening socket has been setup.
.Sp
\&\f(CW$id\fR is the \s-1DCC\s0 connection \s-1ID\s0.
.Sp
\&\f(CW$dest\fR and \f(CW$type\fR are the destination and type of the \s-1DCC\s0 request.
.Sp
\&\f(CW$local_ip\fR is the \f(CW$local_ip\fR argument passed to \f(CW\*(C`start_dcc\*(C'\fR or
the \s-1IP\s0 the socket is bound to.
.Sp
\&\f(CW$local_port\fR is the \s-1TCP\s0 port is the socket is listening on.
.ie n .IP "dcc_request => $id, $src, $type, $arg, $addr, $port" 4
.el .IP "dcc_request => \f(CW$id\fR, \f(CW$src\fR, \f(CW$type\fR, \f(CW$arg\fR, \f(CW$addr\fR, \f(CW$port\fR" 4
.IX Item "dcc_request => $id, $src, $type, $arg, $addr, $port"
Whenever we receive a \s-1DCC\s0 offer from someone else this event is emitted.
\&\f(CW$id\fR is the \s-1DCC\s0 connection \s-1ID\s0, \f(CW$src\fR is his nickname, \f(CW$type\fR is the \s-1DCC\s0
type in lower cases (eg. 'chat').  \f(CW$arg\fR is the \s-1DCC\s0 type argument. \f(CW$addr\fR
is the \s-1IP\s0 address we can reach him at in \s-1ASCII\s0 encoded human readable form (eg.
something like \*(L"127.0.0.1\*(R").  And \f(CW$port\fR is the \s-1TCP\s0 port we have to connect
to.
.Sp
To answer to his request you can just call \f(CW\*(C`dcc_accept\*(C'\fR with the \f(CW$id\fR.
.ie n .IP "dcc_accepted => $id, $type, $hdl" 4
.el .IP "dcc_accepted => \f(CW$id\fR, \f(CW$type\fR, \f(CW$hdl\fR" 4
.IX Item "dcc_accepted => $id, $type, $hdl"
When the locally listening \s-1DCC\s0 socket has received a connection this event is emitted.
.Sp
\&\f(CW$id\fR and \f(CW$type\fR are the \s-1DCC\s0 connection \s-1ID\s0 and type of the \s-1DCC\s0 request.
.Sp
\&\f(CW$hdl\fR is a pre-configured AnyEvent::Handle object, which you only
need to care about in case you want to implement your own \s-1DCC\s0 protocol.
(This event has the on_error and on_eof events pre-configured to cleanup
the data structures in this connection).
.ie n .IP "dcc_connected => $id, $type, $hdl" 4
.el .IP "dcc_connected => \f(CW$id\fR, \f(CW$type\fR, \f(CW$hdl\fR" 4
.IX Item "dcc_connected => $id, $type, $hdl"
Whenever we accepted a \s-1DCC\s0 offer and connected by using \f(CW\*(C`dcc_accept\*(C'\fR this
event is emitted. \f(CW$id\fR is the \s-1DCC\s0 connection \s-1ID\s0.  \f(CW$type\fR is the dcc type in
lower case. \f(CW$hdl\fR is the AnyEvent::Handle object of the connection (see
also \f(CW\*(C`dcc_accepted\*(C'\fR above).
.ie n .IP "dcc_close => $id, $type, $reason" 4
.el .IP "dcc_close => \f(CW$id\fR, \f(CW$type\fR, \f(CW$reason\fR" 4
.IX Item "dcc_close => $id, $type, $reason"
This event is emitted whenever a \s-1DCC\s0 connection is terminated.
.Sp
\&\f(CW$id\fR and \f(CW$type\fR are the \s-1DCC\s0 connection \s-1ID\s0 and type of the \s-1DCC\s0 request.
.Sp
\&\f(CW$reason\fR is a human readable string indicating the reason for the end of
the \s-1DCC\s0 request.
.ie n .IP "dcc_chat_msg => $id, $msg" 4
.el .IP "dcc_chat_msg => \f(CW$id\fR, \f(CW$msg\fR" 4
.IX Item "dcc_chat_msg => $id, $msg"
This event is emitted for a \s-1DCC\s0 \s-1CHAT\s0 message. \f(CW$id\fR is the \s-1DCC\s0 connection
\&\s-1ID\s0 we received the message on. And \f(CW$msg\fR is the message he sent us.
.ie n .IP "quit => $nick, $msg" 4
.el .IP "quit => \f(CW$nick\fR, \f(CW$msg\fR" 4
.IX Item "quit => $nick, $msg"
Emitted when the nickname \f(CW$nick\fR QUITs with the message \f(CW$msg\fR.
.ie n .IP "publicmsg => $channel, $ircmsg" 4
.el .IP "publicmsg => \f(CW$channel\fR, \f(CW$ircmsg\fR" 4
.IX Item "publicmsg => $channel, $ircmsg"
Emitted for \s-1NOTICE\s0 and \s-1PRIVMSG\s0 where the target \f(CW$channel\fR is a channel.
\&\f(CW$ircmsg\fR is the original \s-1IRC\s0 message hash like it is returned by \f(CW\*(C`parse_irc_msg\*(C'\fR.
.Sp
The last parameter of the \f(CW$ircmsg\fR will have all \s-1CTCP\s0 messages stripped off.
.ie n .IP "privatemsg => $nick, $ircmsg" 4
.el .IP "privatemsg => \f(CW$nick\fR, \f(CW$ircmsg\fR" 4
.IX Item "privatemsg => $nick, $ircmsg"
Emitted for \s-1NOTICE\s0 and \s-1PRIVMSG\s0 where the target \f(CW$nick\fR (most of the time you) is a nick.
\&\f(CW$ircmsg\fR is the original \s-1IRC\s0 message hash like it is returned by \f(CW\*(C`parse_irc_msg\*(C'\fR.
.Sp
The last parameter of the \f(CW$ircmsg\fR will have all \s-1CTCP\s0 messages stripped off.
.ie n .IP "error => $code, $message, $ircmsg" 4
.el .IP "error => \f(CW$code\fR, \f(CW$message\fR, \f(CW$ircmsg\fR" 4
.IX Item "error => $code, $message, $ircmsg"
Emitted when any error occurs. \f(CW$code\fR is the 3 digit error id string from \s-1RFC\s0
1459 or the string '\s-1ERROR\s0'. \f(CW$message\fR is a description of the error.
\&\f(CW$ircmsg\fR is the complete error irc message.
.Sp
You may use AnyEvent::IRC::Util::rfc_code_to_name to convert \f(CW$code\fR to the error
name from the \s-1RFC\s0 2812. eg.:
.Sp
.Vb 1
\&   rfc_code_to_name (\*(Aq471\*(Aq) => \*(AqERR_CHANNELISFULL\*(Aq
.Ve
.Sp
\&\s-1NOTE:\s0 This event is also emitted when a '\s-1ERROR\s0' message is received.
.ie n .IP "debug_send => $command, @params" 4
.el .IP "debug_send => \f(CW$command\fR, \f(CW@params\fR" 4
.IX Item "debug_send => $command, @params"
Is emitted everytime some command is sent.
.ie n .IP "debug_recv => $ircmsg" 4
.el .IP "debug_recv => \f(CW$ircmsg\fR" 4
.IX Item "debug_recv => $ircmsg"
Is emitted everytime some command was received.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$cl = AnyEvent::IRC::Client\->new (%args)" 4
.el .IP "\f(CW$cl\fR = AnyEvent::IRC::Client\->new (%args)" 4
.IX Item "$cl = AnyEvent::IRC::Client->new (%args)"
This is the constructor of a AnyEvent::IRC::Client object,
which stands logically for a client connected to \s-1ONE\s0 \s-1IRC\s0 server.
You can reuse it and call \f(CW\*(C`connect\*(C'\fR once it disconnected.
.Sp
\&\fB\s-1NOTE:\s0\fR You are free to use the hash member \f(CW\*(C`heap\*(C'\fR to store any associated
data with this object. For example retry timers or anything else.
.Sp
\&\f(CW%args\fR may contain these options:
.RS 4
.ie n .IP "send_initial_whois => $bool" 4
.el .IP "send_initial_whois => \f(CW$bool\fR" 4
.IX Item "send_initial_whois => $bool"
If this option is enabled an initial \f(CW\*(C`WHOIS\*(C'\fR command is sent to your own
\&\s-1NICKNAME\s0 to determine your own \fIident\fR. See also the method \f(CW\*(C`nick_ident\*(C'\fR.
This is necessary to ensure that the information about your own nickname
is available as early as possible for the \f(CW\*(C`send_long_message\*(C'\fR method.
.Sp
\&\f(CW$bool\fR is \f(CW\*(C`false\*(C'\fR by default.
.RE
.RS 4
.RE
.ie n .IP "$cl\->connect ($host, $port)" 4
.el .IP "\f(CW$cl\fR\->connect ($host, \f(CW$port\fR)" 4
.IX Item "$cl->connect ($host, $port)"
.PD 0
.ie n .IP "$cl\->connect ($host, $port, $info)" 4
.el .IP "\f(CW$cl\fR\->connect ($host, \f(CW$port\fR, \f(CW$info\fR)" 4
.IX Item "$cl->connect ($host, $port, $info)"
.PD
This method does the same as the \f(CW\*(C`connect\*(C'\fR method of AnyEvent::Connection,
but if the \f(CW$info\fR parameter is passed it will automatically register with the
\&\s-1IRC\s0 server upon connect for you, and you won't have to call the \f(CW\*(C`register\*(C'\fR
method yourself.
.Sp
The keys of the hash reference you can pass in \f(CW$info\fR are:
.Sp
.Vb 5
\&   nick      \- the nickname you want to register as
\&   user      \- your username
\&   real      \- your realname
\&   password  \- the server password
\&   timeout   \- the TCP connect timeout
.Ve
.Sp
All keys, except \f(CW\*(C`nick\*(C'\fR are optional.
.ie n .IP "$cl\->register ($nick, $user, $real, $server_pass)" 4
.el .IP "\f(CW$cl\fR\->register ($nick, \f(CW$user\fR, \f(CW$real\fR, \f(CW$server_pass\fR)" 4
.IX Item "$cl->register ($nick, $user, $real, $server_pass)"
Sends the \s-1IRC\s0 registration commands \s-1NICK\s0 and \s-1USER\s0.
If \f(CW$server_pass\fR is passed also a \s-1PASS\s0 command is generated.
.Sp
\&\s-1NOTE:\s0 If you passed the nick, user, etc. already to the \f(CW\*(C`connect\*(C'\fR method
you won't need to call this method, as AnyEvent::IRC::Client will do that
for you.
.ie n .IP "$cl\->set_nick_change_cb ($callback)" 4
.el .IP "\f(CW$cl\fR\->set_nick_change_cb ($callback)" 4
.IX Item "$cl->set_nick_change_cb ($callback)"
This method lets you modify the nickname renaming mechanism when registering
the connection. \f(CW$callback\fR is called with the current nickname as first
argument when a \s-1ERR_NICKNAMEINUSE\s0 or \s-1ERR_UNAVAILRESOURCE\s0 error occurs on login.
The return value of \f(CW$callback\fR will then be used to change the nickname.
.Sp
If \f(CW$callback\fR is not defined the default nick change callback will be used
again.
.Sp
The default callback appends '_' to the end of the nickname supplied in the
\&\f(CW\*(C`register\*(C'\fR routine.
.Sp
If the callback returns the same nickname that was given it the connection
will be terminated.
.ie n .IP "$cl\->nick ()" 4
.el .IP "\f(CW$cl\fR\->nick ()" 4
.IX Item "$cl->nick ()"
Returns the current nickname, under which this connection
is registered at the \s-1IRC\s0 server. It might be different from the
one that was passed to \f(CW\*(C`register\*(C'\fR as a nick-collision might happened
on login.
.ie n .IP "$cl\->is_my_nick ($string)" 4
.el .IP "\f(CW$cl\fR\->is_my_nick ($string)" 4
.IX Item "$cl->is_my_nick ($string)"
This returns true if \f(CW$string\fR is the nick of ourself.
.ie n .IP "$cl\->registered ()" 4
.el .IP "\f(CW$cl\fR\->registered ()" 4
.IX Item "$cl->registered ()"
Returns a true value when the connection has been registered successful and
you can send commands.
.ie n .IP "$cl\->channel_list ()" 4
.el .IP "\f(CW$cl\fR\->channel_list ()" 4
.IX Item "$cl->channel_list ()"
.PD 0
.ie n .IP "$cl\->channel_list ($channel)" 4
.el .IP "\f(CW$cl\fR\->channel_list ($channel)" 4
.IX Item "$cl->channel_list ($channel)"
.PD
Without \f(CW$channel\fR parameter: This returns a hash reference. The keys are the
currently joined channels in lower case.  The values are hash references which
contain the joined nicks as key (\s-1NOT\s0 in lower case!) and the nick modes as
values (as returned from \f(CW\*(C`nick_modes ()\*(C'\fR).
.Sp
If the \f(CW$channel\fR parameter is given it returns the hash reference of the channel
occupants or undef if the channel does not exist.
.ie n .IP "$cl\->nick_modes ($channel, $nick)" 4
.el .IP "\f(CW$cl\fR\->nick_modes ($channel, \f(CW$nick\fR)" 4
.IX Item "$cl->nick_modes ($channel, $nick)"
This returns the mode map of the \f(CW$nick\fR on \f(CW$channel\fR.
Returns undef if the channel isn't joined or the user is not on it.
Returns a hash reference with the modes the user has as keys and 1's as values.
.ie n .IP "$cl\->send_msg (...)" 4
.el .IP "\f(CW$cl\fR\->send_msg (...)" 4
.IX Item "$cl->send_msg (...)"
See also AnyEvent::IRC::Connection.
.ie n .IP "$cl\->send_srv ($command, @params)" 4
.el .IP "\f(CW$cl\fR\->send_srv ($command, \f(CW@params\fR)" 4
.IX Item "$cl->send_srv ($command, @params)"
This function sends an \s-1IRC\s0 message that is constructed by \f(CW\*(C`mk_msg (undef,
$command, @params)\*(C'\fR (see AnyEvent::IRC::Util). If the \f(CW\*(C`registered\*(C'\fR event
has \s-1NOT\s0 yet been emitted the messages are queued until that event is emitted,
and then sent to the server.
.Sp
\&\fB\s-1NOTE:\s0\fR If you stop the registered event (with \f(CW\*(C`stop_event\*(C'\fR, see Object::Event)
in a callback registered to the \f(CW\*(C`before_registered\*(C'\fR event, the \f(CW\*(C`send_srv\*(C'\fR queue
will \fB\s-1NOT\s0\fR be flushed and \fB\s-1NOT\s0\fR sent to the server!
.Sp
This allows you to simply write this:
.Sp
.Vb 3
\&   my $cl = AnyEvent::IRC::Client\->new;
\&   $cl\->connect (\*(Aqirc.freenode.net\*(Aq, 6667, { nick => \*(Aqtestbot\*(Aq });
\&   $cl\->send_srv (PRIVMSG => \*(Aqelmex\*(Aq, \*(AqHi there!\*(Aq);
.Ve
.Sp
Instead of:
.Sp
.Vb 7
\&   my $cl = AnyEvent::IRC::Client\->new;
\&   $cl\->reg_cb (
\&      registered => sub {
\&         $cl\->send_msg (PRIVMSG => \*(Aqelmex\*(Aq, \*(AqHi there!\*(Aq);
\&      }
\&   );
\&   $cl\->connect (\*(Aqirc.freenode.net\*(Aq, 6667, { nick => \*(Aqtestbot\*(Aq });
.Ve
.ie n .IP "$cl\->clear_srv_queue ()" 4
.el .IP "\f(CW$cl\fR\->clear_srv_queue ()" 4
.IX Item "$cl->clear_srv_queue ()"
Clears the server send queue.
.ie n .IP "$cl\->send_chan ($channel, $command, @params)" 4
.el .IP "\f(CW$cl\fR\->send_chan ($channel, \f(CW$command\fR, \f(CW@params\fR)" 4
.IX Item "$cl->send_chan ($channel, $command, @params)"
This function sends a message (constructed by \f(CW\*(C`mk_msg (undef, $command,
@params)\*(C'\fR to the server, like \f(CW\*(C`send_srv\*(C'\fR only that it will queue
the messages if it hasn't joined the channel \f(CW$channel\fR yet. The queued
messages will be send once the connection successfully JOINed the \f(CW$channel\fR.
.Sp
\&\f(CW$channel\fR will be lowercased so that any case that comes from the server matches.
(Yes, \s-1IRC\s0 handles upper and lower case as equal :\-(
.Sp
Be careful with this, there are chances you might not join the channel you
wanted to join. You may wanted to join #bla and the server redirects that
and sends you that you joined #blubb. You may use \f(CW\*(C`clear_chan_queue\*(C'\fR to
remove the queue after some timeout after joining, so that you don't end up
with a memory leak.
.ie n .IP "$cl\->clear_chan_queue ($channel)" 4
.el .IP "\f(CW$cl\fR\->clear_chan_queue ($channel)" 4
.IX Item "$cl->clear_chan_queue ($channel)"
Clears the channel queue of the channel \f(CW$channel\fR.
.ie n .IP "my (@lines) = $cl\->send_long_message ($encoding, $overhead, $cmd, @params, $msg)" 4
.el .IP "my (@lines) = \f(CW$cl\fR\->send_long_message ($encoding, \f(CW$overhead\fR, \f(CW$cmd\fR, \f(CW@params\fR, \f(CW$msg\fR)" 4
.IX Item "my (@lines) = $cl->send_long_message ($encoding, $overhead, $cmd, @params, $msg)"
As \s-1IRC\s0 only allows 512 byte blocks of messages and sometimes
your messages might get longer, you have a problem. This method
will solve your problem:
.Sp
This method can be used to split up long messages into multiple
commands.
.Sp
\&\f(CW$cmd\fR and \f(CW@params\fR are the \s-1IRC\s0 command and it's first parameters,
except the last one: the \f(CW$msg\fR. \f(CW$msg\fR can be a Unicode string,
which will be encoded in \f(CW$encoding\fR before sending.
.Sp
If you want to send a \s-1CTCP\s0 message you can encode it in the \f(CW$cmd\fR by
appending the \s-1CTCP\s0 command with a \f(CW"\e001"\fR. For example if you want to
send a \s-1CTCP\s0 \s-1ACTION\s0 you have to give this \f(CW$cmd\fR:
.Sp
.Vb 1
\&   $cl\->send_long_message (undef, 0, "PRIVMSG\e001ACTION", "#test", "rofls");
.Ve
.Sp
\&\f(CW$encoding\fR can be undef if you don't need any recoding of \f(CW$msg\fR.
But in case you want to send Unicode it is necessary to determine where
to split a message exactly, to not break the encoding.
.Sp
Please also note that the \f(CW\*(C`nick_ident\*(C'\fR for your own nick is necessary to
compute this. To ensure best performance as possible use the
\&\f(CW\*(C`send_initial_whois\*(C'\fR option if you want to use this method.
.Sp
But note that this method might not work 100% correct and you might still get
at least partially chopped off lines if you use \f(CW\*(C`send_long_message\*(C'\fR before the
\&\f(CW\*(C`WHOIS\*(C'\fR reply to \f(CW\*(C`send_initial_whois\*(C'\fR arrived.
.Sp
To be on the safest side you might want to wait until that initial \f(CW\*(C`WHOIS\*(C'\fR
reply arrived.
.Sp
The return value of this method is the list of the actually sent lines (but
without encoding applied).
.ie n .IP "$cl\->enable_ping ($interval, $cb)" 4
.el .IP "\f(CW$cl\fR\->enable_ping ($interval, \f(CW$cb\fR)" 4
.IX Item "$cl->enable_ping ($interval, $cb)"
This method enables a periodical ping to the server with an interval of
\&\f(CW$interval\fR seconds. If no \s-1PONG\s0 was received from the server until the next
interval the connection will be terminated or the callback in \f(CW$cb\fR will be called.
.Sp
(\f(CW$cb\fR will have the connection object as it's first argument.)
.Sp
Make sure you call this method after the connection has been established.
(eg. in the callback for the \f(CW\*(C`registered\*(C'\fR event).
.ie n .IP "$cl\->lower_case ($str)" 4
.el .IP "\f(CW$cl\fR\->lower_case ($str)" 4
.IX Item "$cl->lower_case ($str)"
Converts the given string to lowercase according to \s-1CASEMAPPING\s0 setting given by
the \s-1IRC\s0 server. If none was sent, the default \- rfc1459 \- will be used.
.ie n .IP "$cl\->eq_str ($str1, $str2)" 4
.el .IP "\f(CW$cl\fR\->eq_str ($str1, \f(CW$str2\fR)" 4
.IX Item "$cl->eq_str ($str1, $str2)"
This function compares two strings, whether they are describing the same
\&\s-1IRC\s0 entity. They are lower cased by the networks case rules and compared then.
.ie n .IP "$cl\->isupport ()" 4
.el .IP "\f(CW$cl\fR\->isupport ()" 4
.IX Item "$cl->isupport ()"
.PD 0
.ie n .IP "$cl\->isupport ($key)" 4
.el .IP "\f(CW$cl\fR\->isupport ($key)" 4
.IX Item "$cl->isupport ($key)"
.PD
Provides access to the \s-1ISUPPORT\s0 variables sent by the \s-1IRC\s0 server. If \f(CW$key\fR is
given this method will return its value only, otherwise a hashref with all values
is returned
.ie n .IP "$cl\->split_nick_mode ($prefixed_nick)" 4
.el .IP "\f(CW$cl\fR\->split_nick_mode ($prefixed_nick)" 4
.IX Item "$cl->split_nick_mode ($prefixed_nick)"
This method splits the \f(CW$prefix_nick\fR (eg. '+elmex') up into the
mode of the user and the nickname.
.Sp
This method returns 2 values: the mode map and the nickname.
.Sp
The mode map is a hash reference with the keys being the modes the nick has set
and the values being 1.
.Sp
\&\s-1NOTE:\s0 If you feed in a prefixed ident ('@elmex!elmex@fofofof.de') you get 3 values
out actually: the mode map, the nickname and the ident, otherwise the 3rd value is undef.
.ie n .IP "$cl\->map_prefix_to_mode ($prefix)" 4
.el .IP "\f(CW$cl\fR\->map_prefix_to_mode ($prefix)" 4
.IX Item "$cl->map_prefix_to_mode ($prefix)"
Maps the nick prefix (eg. '@') to the corresponding mode (eg. 'o').
Returns undef if no such prefix exists (on the connected server).
.ie n .IP "$cl\->map_mode_to_prefix ($mode)" 4
.el .IP "\f(CW$cl\fR\->map_mode_to_prefix ($mode)" 4
.IX Item "$cl->map_mode_to_prefix ($mode)"
Maps the nick mode (eg. 'o') to the corresponding prefix (eg. '@').
Returns undef if no such mode exists (on the connected server).
.ie n .IP "$cl\->available_nick_modes ()" 4
.el .IP "\f(CW$cl\fR\->available_nick_modes ()" 4
.IX Item "$cl->available_nick_modes ()"
Returns a list of possible modes on this \s-1IRC\s0 server. (eg. 'o' for op).
.ie n .IP "$cl\->is_channel_name ($string)" 4
.el .IP "\f(CW$cl\fR\->is_channel_name ($string)" 4
.IX Item "$cl->is_channel_name ($string)"
This return true if \f(CW$string\fR is a channel name. It analyzes the prefix
of the string (eg. if it is '#') and returns true if it finds a channel prefix.
Those prefixes might be server specific, so \s-1ISUPPORT\s0 is checked for that too.
.ie n .IP "$cl\->nick_ident ($nick)" 4
.el .IP "\f(CW$cl\fR\->nick_ident ($nick)" 4
.IX Item "$cl->nick_ident ($nick)"
This method returns the whole ident of the \f(CW$nick\fR if the informations is available.
If the nick's ident hasn't been seen yet, undef is returned.
.Sp
\&\fB\s-1NOTE:\s0\fR If you want to rely on the \f(CW\*(C`nick_ident\*(C'\fR of your own nick you should
make sure to enable the \f(CW\*(C`send_initial_whois\*(C'\fR option in the constructor.
.ie n .IP "my $bool = $cl\->away_status" 4
.el .IP "my \f(CW$bool\fR = \f(CW$cl\fR\->away_status" 4
.IX Item "my $bool = $cl->away_status"
Returns a true value if you are away or undef if you are not away.
.ie n .IP "$cl\->ctcp_auto_reply ($ctcp_command, @msg)" 4
.el .IP "\f(CW$cl\fR\->ctcp_auto_reply ($ctcp_command, \f(CW@msg\fR)" 4
.IX Item "$cl->ctcp_auto_reply ($ctcp_command, @msg)"
.PD 0
.ie n .IP "$cl\->ctcp_auto_reply ($ctcp_command, $coderef)" 4
.el .IP "\f(CW$cl\fR\->ctcp_auto_reply ($ctcp_command, \f(CW$coderef\fR)" 4
.IX Item "$cl->ctcp_auto_reply ($ctcp_command, $coderef)"
.PD
This method installs an auto-reply for the reception of the \f(CW$ctcp_command\fR
via \s-1PRIVMSG\s0, \f(CW@msg\fR will be used as argument to the \f(CW\*(C`encode_ctcp\*(C'\fR function of
the AnyEvent::IRC::Util package. The replies will be sent with the \s-1NOTICE\s0
\&\s-1IRC\s0 command.
.Sp
If \f(CW$coderef\fR was given and is a code reference, it will called each time a
\&\f(CW$ctcp_command\fR is received, this is useful for eg.  \s-1CTCP\s0 \s-1PING\s0 reply
generation. The arguments will be the same arguments that the \f(CW\*(C`ctcp\*(C'\fR event
callbacks get. (See also \f(CW\*(C`ctcp\*(C'\fR event description above).  The return value of
the called subroutine should be a list of arguments for \f(CW\*(C`encode_ctcp\*(C'\fR.
.Sp
Currently you can only configure one auto-reply per \f(CW$ctcp_command\fR.
.Sp
Example:
.Sp
.Vb 1
\&   $cl\->ctcp_auto_reply (\*(AqVERSION\*(Aq, [\*(AqVERSION\*(Aq, \*(AqScriptBla:0.1:Perl\*(Aq]);
\&
\&   $cl\->ctcp_auto_reply (\*(AqPING\*(Aq, sub {
\&      my ($cl, $src, $target, $tag, $msg, $type) = @_;
\&      [\*(AqPING\*(Aq, $msg]
\&   });
.Ve
.ie n .IP "$cl\->dcc_initiate ($dest, $type, $timeout, $local_ip, $local_port)" 4
.el .IP "\f(CW$cl\fR\->dcc_initiate ($dest, \f(CW$type\fR, \f(CW$timeout\fR, \f(CW$local_ip\fR, \f(CW$local_port\fR)" 4
.IX Item "$cl->dcc_initiate ($dest, $type, $timeout, $local_ip, $local_port)"
This function will initiate a \s-1DCC\s0 \s-1TCP\s0 connection to \f(CW$dest\fR of type \f(CW$type\fR.
It will setup a listening \s-1TCP\s0 socket on \f(CW$local_port\fR, or a random port if
\&\f(CW$local_port\fR is undefined. \f(CW$local_ip\fR is the \s-1IP\s0 that is being sent to the
receiver of the \s-1DCC\s0 connection. If it is undef the local socket will be bound
to 0 (or \*(L"::\*(R" in case of IPv6) and \f(CW$local_ip\fR will probably be something like
\&\*(L"0.0.0.0\*(R". It is always advisable to set \f(CW$local_ip\fR to a (from the \*(L"outside\*(R",
what ever that might be) reachable \s-1IP\s0 Address.
.Sp
\&\f(CW$timeout\fR is the time in seconds after which the listening socket will be
closed if the receiver didn't connect yet. The default is 300 (5 minutes).
.Sp
When the local listening socket has been setup the \f(CW\*(C`dcc_ready\*(C'\fR event is
emitted.  When the receiver connects to the socket the \f(CW\*(C`dcc_accepted\*(C'\fR event is
emitted.  And whenever a dcc connection is closed the \f(CW\*(C`dcc_close\*(C'\fR event is
emitted.
.Sp
For canceling the \s-1DCC\s0 offer or closing the connection see \f(CW\*(C`dcc_disconnect\*(C'\fR below.
.Sp
The return value of this function will be the \s-1ID\s0 of the initiated \s-1DCC\s0 connection,
which can be used for functions such as \f(CW\*(C`dcc_disconnect\*(C'\fR, \f(CW\*(C`send_dcc_chat\*(C'\fR or
\&\f(CW\*(C`dcc_handle\*(C'\fR.
.ie n .IP "$cl\->dcc_disconnect ($id, $reason)" 4
.el .IP "\f(CW$cl\fR\->dcc_disconnect ($id, \f(CW$reason\fR)" 4
.IX Item "$cl->dcc_disconnect ($id, $reason)"
In case you want to withdraw a \s-1DCC\s0 offer sent by \f(CW\*(C`start_dcc\*(C'\fR or close
a \s-1DCC\s0 connection you call this function.
.Sp
\&\f(CW$id\fR is the \s-1DCC\s0 connection \s-1ID\s0.  \f(CW$reason\fR should be a human readable reason
why you ended the dcc offer, but it's only used for local logging purposes (see
\&\f(CW\*(C`dcc_close\*(C'\fR event).
.ie n .IP "$cl\->dcc_accept ($id, $timeout)" 4
.el .IP "\f(CW$cl\fR\->dcc_accept ($id, \f(CW$timeout\fR)" 4
.IX Item "$cl->dcc_accept ($id, $timeout)"
This will accept an incoming \s-1DCC\s0 request as received by the \f(CW\*(C`dcc_request\*(C'\fR
event. The \f(CW\*(C`dcc_connected\*(C'\fR event will be emitted when we successfully
connected. And the \f(CW\*(C`dcc_close\*(C'\fR event when the connection was disconnected.
.Sp
\&\f(CW$timeout\fR is the connection try timeout in seconds. The default is 300 (5 minutes).
.SH "EXAMPLES"
.IX Header "EXAMPLES"
See samples/anyeventirccl and other samples in samples/ for some examples on how to use AnyEvent::IRC::Client.
.SH "AUTHOR"
.IX Header "AUTHOR"
Robin Redeker, \f(CW\*(C`<elmex@ta\-sa.org>\*(C'\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
AnyEvent::IRC::Connection
.PP
\&\s-1RFC\s0 1459 \- Internet Relay Chat: Client Protocol
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2006\-2009 Robin Redeker, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
