.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::IRC::Util 3"
.TH AnyEvent::IRC::Util 3 "2010-09-14" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::IRC::Util \- Common utilities that help with IRC protocol handling
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use AnyEvent::IRC::Util qw/parse_irc_msg mk_msg/;
\&
\&   my $msgdata = mk_msg (undef, PRIVMSG => "mcmanus", "my hands glow!");
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
These are some utility functions that might come in handy when
handling the \s-1IRC\s0 protocol.
.PP
You can export these with eg.:
.PP
.Vb 1
\&   use AnyEvent::IRC::Util qw/parse_irc_msg/;
.Ve
.IP "\fBparse_irc_msg ($ircline)\fR" 4
.IX Item "parse_irc_msg ($ircline)"
This method parses the \f(CW$ircline\fR, which is one line of the \s-1IRC\s0 protocol
without the trailing \*(L"\e015\e012\*(R".
.Sp
It returns a hash which has the following entrys:
.RS 4
.IP "prefix" 4
.IX Item "prefix"
The message prefix.
.IP "command" 4
.IX Item "command"
The \s-1IRC\s0 command.
.IP "params" 4
.IX Item "params"
The parameters to the \s-1IRC\s0 command in a array reference,
this includes the trailing parameter (the one after the ':' or
the 14th parameter).
.RE
.RS 4
.RE
.ie n .IP "\fBmk_msg ($prefix, \fB$command\fB, \f(BI@params\fB)\fR" 4
.el .IP "\fBmk_msg ($prefix, \f(CB$command\fB, \f(CB@params\fB)\fR" 4
.IX Item "mk_msg ($prefix, $command, @params)"
This function assembles a \s-1IRC\s0 message. The generated
message will look like (pseudo code!)
.Sp
.Vb 1
\&   :<prefix> <command> <params> :<trail>
.Ve
.Sp
Please refer to \s-1RFC\s0 1459 how \s-1IRC\s0 messages normally look like.
.Sp
The prefix will be omitted if they are \f(CW\*(C`undef\*(C'\fR.
.Sp
Please note that only the last parameter may contain spaces, and if it
contains spaces it will be quoted as the trailing part of the
\&\s-1IRC\s0 message.
.Sp
\&\s-1NOTE:\s0 The trailing \*(L"\e015\e012\*(R" is \s-1NOT\s0 added by this function!
.Sp
\&\s-1EXAMPLES:\s0
.Sp
.Vb 2
\&   mk_msg (undef, "PRIVMSG", "magnus", "you suck!");
\&   # will return: "PRIVMSG magnus :you suck!"
\&
\&   mk_msg (undef, "PRIVMSG", "magnus", "Hi!");
\&   # will return: "PRIVMSG magnus :Hi!"
\&
\&   mk_msg (undef, "JOIN", "#test");
\&   # will return: "JOIN #test"
.Ve
.IP "\fBdecode_ctcp ($data)\fR" 4
.IX Item "decode_ctcp ($data)"
This function decodes \s-1CTCP\s0 messages contained in an \s-1IRC\s0 message.
\&\f(CW$data\fR should be the last parameter of a \s-1IRC\s0 \s-1PRIVMSG\s0 or \s-1NOTICE\s0.
.Sp
It will first unescape the lower layer, extract \s-1CTCP\s0 messages
and then return a list with two elements: the line without the \s-1CTCP\s0 messages
and an array reference which contains array references of \s-1CTCP\s0 messages.
Those \s-1CTCP\s0 message array references will have the \s-1CTCP\s0 message tag as
first element (eg. \*(L"\s-1VERSION\s0\*(R") and the rest of the \s-1CTCP\s0 message as the second
element.
.IP "\fBencode_ctcp (@msg)\fR" 4
.IX Item "encode_ctcp (@msg)"
This function encodes a \s-1CTCP\s0 message for the transmission via the \s-1NOTICE\s0
or \s-1PRIVMSG\s0 command. \f(CW@msg\fR is an array of strings or array references.
If an array reference occurs in the \f(CW@msg\fR array it's first
element will be interpreted as \s-1CTCP\s0 \s-1TAG\s0 (eg. one of \s-1PING\s0, \s-1VERSION\s0, .. whatever)
the rest of the array ref will be appended to the tag and seperated by
spaces.
.Sp
All parts of the message will be concatenated and lowlevel quoted.
That means you can embed _any_ character from 0 to 255 in this message (thats
what the lowlevel quoting allows).
.IP "\fBfilter_colors ($line)\fR" 4
.IX Item "filter_colors ($line)"
This function will filter out any mIRC colors and (most) ansi escape sequences.
Unfortunately the mIRC color coding will destroy improper colored numbers. So this
function may destroy the message in some occasions a bit.
.IP "\fBsplit_prefix ($prefix)\fR" 4
.IX Item "split_prefix ($prefix)"
This function splits an \s-1IRC\s0 user prefix as described by \s-1RFC\s0 2817
into the three parts: nickname, user and host. Which will be
returned as a list with that order.
.Sp
\&\f(CW$prefix\fR can also be a hash like it is returned by \f(CW\*(C`parse_irc_msg\*(C'\fR.
.IP "\fBis_nick_prefix ($prefix)\fR" 4
.IX Item "is_nick_prefix ($prefix)"
Returns true if the prefix is a nick prefix, containing user and host.
.ie n .IP "\fBjoin_prefix ($nick, \fB$user\fB, \f(BI$host\fB)\fR" 4
.el .IP "\fBjoin_prefix ($nick, \f(CB$user\fB, \f(CB$host\fB)\fR" 4
.IX Item "join_prefix ($nick, $user, $host)"
Joins \f(CW$nick\fR, \f(CW$user\fR and \f(CW$host\fR together to form a prefix.
.IP "\fBprefix_nick ($prefix)\fR" 4
.IX Item "prefix_nick ($prefix)"
A shortcut to extract the nickname from the \f(CW$prefix\fR.
.Sp
\&\f(CW$prefix\fR can also be a hash like it is returned by \f(CW\*(C`parse_irc_msg\*(C'\fR.
.IP "\fBprefix_user ($prefix)\fR" 4
.IX Item "prefix_user ($prefix)"
A shortcut to extract the username from the \f(CW$prefix\fR.
.Sp
\&\f(CW$prefix\fR can also be a hash like it is returned by \f(CW\*(C`parse_irc_msg\*(C'\fR.
.IP "\fBprefix_host ($prefix)\fR" 4
.IX Item "prefix_host ($prefix)"
A shortcut to extract the hostname from the \f(CW$prefix\fR.
.Sp
\&\f(CW$prefix\fR can also be a hash like it is returned by \f(CW\*(C`parse_irc_msg\*(C'\fR.
.IP "\fBrfc_code_to_name ($code)\fR" 4
.IX Item "rfc_code_to_name ($code)"
This function is a interface to the internal mapping or numeric
replies to the reply name in \s-1RFC\s0 2812 (which you may also consult).
.Sp
\&\f(CW$code\fR is returned if no name for \f(CW$code\fR exists
(as some server may extended the protocol).
.ie n .IP "my (@lines) = split_unicode_string ($encoding, $string, $maxlinebytes)" 4
.el .IP "my (@lines) = split_unicode_string ($encoding, \f(CW$string\fR, \f(CW$maxlinebytes\fR)" 4
.IX Item "my (@lines) = split_unicode_string ($encoding, $string, $maxlinebytes)"
This function splits up \f(CW$string\fR into multiple \f(CW@lines\fR which are
not longer than \f(CW$maxlinebytes\fR bytes. Encoding can be given in \f(CW$encoding\fR.
(eg. 'utf\-8'). But the output will not be encoded.
.Sp
This function takes care that your characters are not garbled.
.SH "AUTHOR"
.IX Header "AUTHOR"
Robin Redeker, \f(CW\*(C`<elmex@ta\-sa.org>\*(C'\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Internet Relay Chat Client To Client Protocol from February 2, 1997
http://www.invlogic.com/irc/ctcp.html
.PP
\&\s-1RFC\s0 1459 \- Internet Relay Chat: Client Protocol
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2006\-2009 Robin Redeker, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
