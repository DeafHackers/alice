.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI 3"
.TH DBI 3 "2012-05-16" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::DBI \- asynchronous DBI access
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use AnyEvent::DBI;
\&
\&   my $cv = AnyEvent\->condvar;
\&
\&   my $dbh = new AnyEvent::DBI "DBI:SQLite:dbname=test.db", "", "";
\&
\&   $dbh\->exec ("select * from test where num=?", 10, sub {
\&      my ($dbh, $rows, $rv) = @_;
\&
\&      $#_ or die "failure: $@";
\&
\&      print "@$_\en"
\&         for @$rows;
\&
\&      $cv\->broadcast;
\&   });
\&
\&   # asynchronously do sth. else here
\&
\&   $cv\->wait;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is an AnyEvent user, you need to make sure that you use and
run a supported event loop.
.PP
This module implements asynchronous \s-1DBI\s0 access by forking or executing
separate \*(L"DBI-Server\*(R" processes and sending them requests.
.PP
It means that you can run \s-1DBI\s0 requests in parallel to other tasks.
.PP
The overhead for very simple statements (\*(L"select 0\*(R") is somewhere
around 100% to 120% (dual/single core \s-1CPU\s0) compared to an explicit
prepare_cached/execute/fetchrow_arrayref/finish combination.
.SS "\s-1ERROR\s0 \s-1HANDLING\s0"
.IX Subsection "ERROR HANDLING"
This module defines a number of functions that accept a callback
argument. All callbacks used by this module get their AnyEvent::DBI handle
object passed as first argument.
.PP
If the request was successful, then there will be more arguments,
otherwise there will only be the \f(CW$dbh\fR argument and \f(CW$@\fR contains an
error message.
.PP
A convinient way to check whether an error occured is to check \f(CW$#_\fR \-
if that is true, then the function was successful, otherwise there was an
error.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.ie n .IP "$dbh = new AnyEvent::DBI $database, $user, $pass, [key => value]..." 4
.el .IP "\f(CW$dbh\fR = new AnyEvent::DBI \f(CW$database\fR, \f(CW$user\fR, \f(CW$pass\fR, [key => value]..." 4
.IX Item "$dbh = new AnyEvent::DBI $database, $user, $pass, [key => value]..."
Returns a database handle for the given database. Each database handle
has an associated server process that executes statements in order. If
you want to run more than one statement in parallel, you need to create
additional database handles.
.Sp
The advantage of this approach is that transactions work as state is
preserved.
.Sp
Example:
.Sp
.Vb 2
\&   $dbh = new AnyEvent::DBI
\&             "DBI:mysql:test;mysql_read_default_file=/root/.my.cnf", "", "";
.Ve
.Sp
Additional key-value pairs can be used to adjust behaviour:
.RS 4
.ie n .IP "on_error => $callback\->($dbh, $filename, $line, $fatal)" 4
.el .IP "on_error => \f(CW$callback\fR\->($dbh, \f(CW$filename\fR, \f(CW$line\fR, \f(CW$fatal\fR)" 4
.IX Item "on_error => $callback->($dbh, $filename, $line, $fatal)"
When an error occurs, then this callback will be invoked. On entry, \f(CW$@\fR
is set to the error message. \f(CW$filename\fR and \f(CW$line\fR is where the
original request was submitted.
.Sp
If the fatal argument is true then the database connection is shut down
and your database handle became invalid. In addition to invoking the
\&\f(CW\*(C`on_error\*(C'\fR callback, all of your queued request callbacks are called
without only the \f(CW$dbh\fR argument.
.Sp
If omitted, then \f(CW\*(C`die\*(C'\fR will be called on any errors, fatal or not.
.ie n .IP "on_connect => $callback\->($dbh[, $success])" 4
.el .IP "on_connect => \f(CW$callback\fR\->($dbh[, \f(CW$success\fR])" 4
.IX Item "on_connect => $callback->($dbh[, $success])"
If you supply an \f(CW\*(C`on_connect\*(C'\fR callback, then this callback will be
invoked after the database connect attempt. If the connection succeeds,
\&\f(CW$success\fR is true, otherwise it is missing and \f(CW$@\fR contains the
\&\f(CW$DBI::errstr\fR.
.Sp
Regardless of whether \f(CW\*(C`on_connect\*(C'\fR is supplied, connect errors will result in
\&\f(CW\*(C`on_error\*(C'\fR being called. However, if no \f(CW\*(C`on_connect\*(C'\fR callback is supplied, then
connection errors are considered fatal. The client will \f(CW\*(C`die\*(C'\fR and the \f(CW\*(C`on_error\*(C'\fR
callback will be called with \f(CW$fatal\fR true.
.Sp
When on_connect is supplied, connect error are not fatal and AnyEvent::DBI
will not \f(CW\*(C`die\*(C'\fR. You still cannot, however, use the \f(CW$dbh\fR object you
received from \f(CW\*(C`new\*(C'\fR to make requests.
.IP "exec_server => 1" 4
.IX Item "exec_server => 1"
If you supply an \f(CW\*(C`exec_server\*(C'\fR argument, then the \s-1DBI\s0 server process will
fork and exec another perl interpreter (using \f(CW$^X\fR) with just the
AnyEvent::DBI proxy running. This will provide the cleanest possible proxy
for your database server.
.Sp
If you do not supply the \f(CW\*(C`exec_server\*(C'\fR argument (or supply it with a
false value) then the traditional method of starting the server by forking
the current process is used. The forked interpreter will try to clean
itself up by calling POSIX::close on all file descriptors except \s-1STDIN\s0,
\&\s-1STDOUT\s0, and \s-1STDERR\s0 (and the socket it uses to communicate with the cilent,
of course).
.IP "timeout => seconds" 4
.IX Item "timeout => seconds"
If you supply a timeout parameter (fractional values are supported), then
a timer is started any time the \s-1DBI\s0 handle expects a response from the
server. This includes connection setup as well as requests made to the
backend. The timeout spans the duration from the moment the first data
is written (or queued to be written) until all expected responses are
returned, but is postponed for \*(L"timeout\*(R" seconds each time more data is
returned from the server. If the timer ever goes off then a fatal error is
generated. If you have an \f(CW\*(C`on_error\*(C'\fR handler installed, then it will be
called, otherwise your program will \fIdie()\fR.
.Sp
When altering your databases with timeouts it is wise to use
transactions. If you quit due to timeout while performing insert, update
or schema-altering commands you can end up not knowing if the action was
submitted to the database, complicating recovery.
.Sp
Timeout errors are always fatal.
.RE
.RS 4
.Sp
Any additional key-value pairs will be rolled into a hash reference
and passed as the final argument to the \f(CW\*(C`DBI\->connect (...)\*(C'\fR
call. For example, to supress errors on \s-1STDERR\s0 and send them instead to an
AnyEvent::Handle you could do:
.Sp
.Vb 6
\&   $dbh = new AnyEvent::DBI
\&              "DBI:mysql:test;mysql_read_default_file=/root/.my.cnf", "", "",
\&              PrintError => 0,
\&              on_error   => sub {
\&                 $log_handle\->push_write ("DBI Error: $@ at $_[1]:$_[2]\en");
\&              };
.Ve
.RE
.ie n .IP "$dbh\->on_error ($cb\->($dbh, $filename, $line, $fatal))" 4
.el .IP "\f(CW$dbh\fR\->on_error ($cb\->($dbh, \f(CW$filename\fR, \f(CW$line\fR, \f(CW$fatal\fR))" 4
.IX Item "$dbh->on_error ($cb->($dbh, $filename, $line, $fatal))"
Sets (or clears, with \f(CW\*(C`undef\*(C'\fR) the \f(CW\*(C`on_error\*(C'\fR handler.
.ie n .IP "$dbh\->timeout ($seconds)" 4
.el .IP "\f(CW$dbh\fR\->timeout ($seconds)" 4
.IX Item "$dbh->timeout ($seconds)"
Sets (or clears, with \f(CW\*(C`undef\*(C'\fR) the database timeout. Useful to extend the
timeout when you are about to make a really long query.
.ie n .IP "$dbh\->exec (""statement"", @args, $cb\->($dbh, \e@rows, $rv))" 4
.el .IP "\f(CW$dbh\fR\->exec (``statement'', \f(CW@args\fR, \f(CW$cb\fR\->($dbh, \e@rows, \f(CW$rv\fR))" 4
.IX Item "$dbh->exec (statement, @args, $cb->($dbh, @rows, $rv))"
Executes the given \s-1SQL\s0 statement with placeholders replaced by
\&\f(CW@args\fR. The statement will be prepared and cached on the server side, so
using placeholders is extremely important.
.Sp
The callback will be called with a weakened AnyEvent::DBI object as the
first argument and the result of \f(CW\*(C`fetchall_arrayref\*(C'\fR as (or \f(CW\*(C`undef\*(C'\fR
if the statement wasn't a select statement) as the second argument.
.Sp
Third argument is the return value from the \f(CW\*(C`DBI\->execute\*(C'\fR method
call.
.Sp
If an error occurs and the \f(CW\*(C`on_error\*(C'\fR callback returns, then only \f(CW$dbh\fR
will be passed and \f(CW$@\fR contains the error message.
.ie n .IP "$dbh\->attr ($attr_name[, $attr_value], $cb\->($dbh, $new_value))" 4
.el .IP "\f(CW$dbh\fR\->attr ($attr_name[, \f(CW$attr_value\fR], \f(CW$cb\fR\->($dbh, \f(CW$new_value\fR))" 4
.IX Item "$dbh->attr ($attr_name[, $attr_value], $cb->($dbh, $new_value))"
An accessor for the handle attributes, such as \f(CW\*(C`AutoCommit\*(C'\fR,
\&\f(CW\*(C`RaiseError\*(C'\fR, \f(CW\*(C`PrintError\*(C'\fR and so on. If you provide an \f(CW$attr_value\fR
(which might be \f(CW\*(C`undef\*(C'\fR), then the given attribute will be set to that
value.
.Sp
The callback will be passed the database handle and the attribute's value
if successful.
.Sp
If an error occurs and the \f(CW\*(C`on_error\*(C'\fR callback returns, then only \f(CW$dbh\fR
will be passed and \f(CW$@\fR contains the error message.
.ie n .IP "$dbh\->begin_work ($cb\->($dbh[, $rc]))" 4
.el .IP "\f(CW$dbh\fR\->begin_work ($cb\->($dbh[, \f(CW$rc\fR]))" 4
.IX Item "$dbh->begin_work ($cb->($dbh[, $rc]))"
.PD 0
.ie n .IP "$dbh\->commit     ($cb\->($dbh[, $rc]))" 4
.el .IP "\f(CW$dbh\fR\->commit     ($cb\->($dbh[, \f(CW$rc\fR]))" 4
.IX Item "$dbh->commit     ($cb->($dbh[, $rc]))"
.ie n .IP "$dbh\->rollback   ($cb\->($dbh[, $rc]))" 4
.el .IP "\f(CW$dbh\fR\->rollback   ($cb\->($dbh[, \f(CW$rc\fR]))" 4
.IX Item "$dbh->rollback   ($cb->($dbh[, $rc]))"
.PD
The begin_work, commit, and rollback methods expose the equivalent
transaction control method of the \s-1DBI\s0 driver. On success, \f(CW$rc\fR is true.
.Sp
If an error occurs and the \f(CW\*(C`on_error\*(C'\fR callback returns, then only \f(CW$dbh\fR
will be passed and \f(CW$@\fR contains the error message.
.ie n .IP "$dbh\->func ('string_which_yields_args_when_evaled', $func_name, $cb\->($dbh, $rc, $dbi_err, $dbi_errstr))" 4
.el .IP "\f(CW$dbh\fR\->func ('string_which_yields_args_when_evaled', \f(CW$func_name\fR, \f(CW$cb\fR\->($dbh, \f(CW$rc\fR, \f(CW$dbi_err\fR, \f(CW$dbi_errstr\fR))" 4
.IX Item "$dbh->func ('string_which_yields_args_when_evaled', $func_name, $cb->($dbh, $rc, $dbi_err, $dbi_errstr))"
This gives access to database driver private methods. Because they
are not standard you cannot always depend on the value of \f(CW$rc\fR or
\&\f(CW$dbi_err\fR. Check the documentation for your specific driver/function
combination to see what it returns.
.Sp
Note that the first argument will be eval'ed to produce the argument list to
the \fIfunc()\fR method. This must be done because the serialization protocol
between the AnyEvent::DBI server process and your program does not support the
passage of closures.
.Sp
Here's an example to extend the query language in SQLite so it supports an
\&\fIintstr()\fR function:
.Sp
.Vb 10
\&    $cv = AnyEvent\->condvar;
\&    $dbh\->func (
\&       q{
\&          instr => 2, sub {
\&             my ($string, $search) = @_;
\&             return index $string, $search;
\&          },
\&       },
\&       create_function => sub {
\&          return $cv\->send ($@)
\&             unless $#_;
\&          $cv\->send (undef, @_[1,2,3]);
\&       }
\&    );
\&
\&    my ($err,$rc,$errcode,$errstr) = $cv\->recv;
\&
\&    die $err if defined $err;
\&    die "EVAL failed: $errstr"
\&       if $errcode;
\&
\&    # otherwise, we can ignore $rc and $errcode for this particular func
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
AnyEvent, \s-1DBI\s0, Coro::Mysql.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\&   Marc Lehmann <schmorp@schmorp.de>
\&   http://home.schmorp.de/
\&
\&   Adam Rosenstein <adam@redcondor.com>
\&   http://www.redcondor.com/
.Ve
